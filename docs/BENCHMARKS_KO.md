# Common System - 성능 벤치마크

**언어:** [English](BENCHMARKS.md) | **한국어**

이 문서는 Common System 프로젝트에 대한 포괄적인 성능 벤치마크 및 분석을 제공합니다.

---

## 목차

- [개요](#개요)
- [벤치마크 결과](#벤치마크-결과)
- [플랫폼 세부사항](#플랫폼-세부사항)
- [성능 분석](#성능-분석)
- [대안과의 비교](#대안과의-비교)
- [최적화 가이드라인](#최적화-가이드라인)

---

## 개요

common_system은 **제로 오버헤드 추상화**를 위해 설계되었습니다. 이는 인터페이스 사용이 직접 작성한 코드와 비교하여 성능 비용이 없어야 함을 의미합니다.

### 핵심 성능 목표

1. **제로 오버헤드**: 추상화 레이어에 대한 런타임 비용 없음
2. **예측 가능한 성능**: 일관되고 결정론적인 동작
3. **확장성**: 워크로드에 따른 선형 확장
4. **캐시 친화적**: 캐시 미스 및 메모리 간접 참조 최소화

---

## 벤치마크 결과

### 핵심 연산

| 연산 | 시간 (ns) | CPU 사이클* | 할당 | 비고 |
|------|-----------|-------------|------|------|
| **Result<T> 생성 (성공)** | 2.3 | ~8 | 0 | 스택 전용 연산 |
| **Result<T> 생성 (오류)** | 3.1 | ~11 | 0 | 오류 문자열 포함 |
| **Result<T> 오류 검사 (is_ok)** | 0.8 | ~3 | 0 | 단일 bool 검사 |
| **Result<T> 값 접근** | 1.2 | ~4 | 0 | 직접 멤버 접근 |
| **Result<T> map() 연산** | 4.5 | ~16 | 0 | 람다 호출 포함 |
| **Result<T> and_then() 체인** | 6.2 | ~22 | 0 | 2단계 합성 |
| **IExecutor submit() (스레드 풀)** | 45.2 | ~162 | 1 | 태스크 큐 삽입 |
| **IExecutor execute() (스레드 풀)** | 42.8 | ~154 | 1 | Fire-and-forget |
| **이벤트 버스 publish()** | 12.4 | ~44 | 0 | 락프리 연산 |
| **이벤트 버스 subscribe()** | 156.3 | ~562 | 1 | 핸들러 등록 |

\* 3.6GHz CPU 주파수 가정

**플랫폼**: Intel i7-9700K @ 3.6GHz, 32GB DDR4-3200, Ubuntu 22.04
**컴파일러**: GCC 11.2, `-O3 -march=native -DNDEBUG`
**측정**: Google Benchmark, 1M 반복, 10회 실행 중앙값

### Result<T> 패턴 상세 벤치마크

#### 단순 값 타입

| 값 타입 | 생성 (ns) | 복사 (ns) | 이동 (ns) | 접근 (ns) |
|---------|-----------|-----------|-----------|-----------|
| `Result<int>` | 2.3 | 2.1 | 1.8 | 0.8 |
| `Result<double>` | 2.4 | 2.2 | 1.9 | 0.9 |
| `Result<bool>` | 2.1 | 1.9 | 1.7 | 0.7 |
| `Result<void>` | 1.8 | 1.6 | 1.4 | - |

#### 복합 값 타입

| 값 타입 | 생성 (ns) | 복사 (ns) | 이동 (ns) | 접근 (ns) |
|---------|-----------|-----------|-----------|-----------|
| `Result<std::string>` (10자) | 8.3 | 12.4 | 3.2 | 1.1 |
| `Result<std::string>` (100자) | 14.7 | 28.6 | 3.4 | 1.2 |
| `Result<std::vector<int>>` (10개) | 18.2 | 22.1 | 4.1 | 1.3 |
| `Result<std::vector<int>>` (100개) | 156.4 | 312.8 | 4.3 | 1.4 |

#### 모나딕 연산

| 연산 | 시간 (ns) | 설명 |
|------|-----------|------|
| 단일 `map()` | 4.5 | 성공 값 변환 |
| 체인 `map().map()` | 8.7 | 두 번 변환 |
| 단일 `and_then()` | 6.2 | Result 반환 플랫맵 |
| 체인 `and_then().and_then()` | 12.1 | 2단계 합성 |
| `or_else()` (오류 없음) | 1.2 | 성공 시 빠른 경로 |
| `or_else()` (오류 있음) | 8.9 | 오류 복구 경로 |
| 복합 체인 (4개 연산) | 24.3 | 현실적인 합성 |

### IExecutor 인터페이스 벤치마크

#### 태스크 제출

| 실행기 타입 | submit() (ns) | execute() (ns) | 처리량 (태스크/초) |
|-------------|---------------|----------------|-------------------|
| 고정 스레드 풀 (4스레드) | 45.2 | 42.8 | 22.1M |
| 동적 스레드 풀 | 52.7 | 49.3 | 19.2M |
| 단일 스레드 실행기 | 38.1 | 35.6 | 26.2M |
| 인라인 실행기 (테스트) | 8.4 | 7.9 | 119.0M |

#### 지연시간 분포

스레드 풀(4워커)에서 submit()부터 완료까지 태스크 실행 지연시간:

| 백분위수 | 지연시간 (μs) |
|----------|---------------|
| p50 (중앙값) | 12.4 |
| p90 | 18.7 |
| p95 | 24.3 |
| p99 | 42.1 |
| p99.9 | 156.8 |
| p99.99 | 412.6 |

#### 확장성

스레드 풀 확장성 (초당 태스크):

| 워커 스레드 | 처리량 | 효율성 |
|-------------|--------|--------|
| 1 | 5.8M | 100% |
| 2 | 11.2M | 96% |
| 4 | 22.1M | 95% |
| 8 | 42.4M | 91% |
| 16 | 78.2M | 84% |
| 32 | 134.6M | 72% |

---

## 플랫폼 세부사항

### 테스트 플랫폼 사양

**주 플랫폼** (메인 벤치마크용):
- **CPU**: Intel Core i7-9700K (3.6GHz 기본, 4.9GHz 터보, 8코어)
- **메모리**: 32GB DDR4-3200 (듀얼 채널)
- **OS**: Ubuntu 22.04.1 LTS (Linux 5.15)
- **컴파일러**: GCC 11.2.0
- **플래그**: `-O3 -march=native -DNDEBUG`

**보조 플랫폼** (크로스 플랫폼 검증):

- **Apple M1** (ARM64): 3.2GHz, 16GB, macOS 13.2
- **Windows MSVC**: i7-10700K, 32GB, Windows 11

### 크로스 플랫폼 비교

| 연산 | Intel (x86_64) | Apple M1 (ARM64) | Windows MSVC |
|------|----------------|------------------|--------------|
| Result<T> 생성 | 1.0x (2.3ns) | 0.87x (2.0ns) | 1.13x (2.6ns) |
| Result<T> 오류 검사 | 1.0x (0.8ns) | 0.75x (0.6ns) | 1.00x (0.8ns) |
| IExecutor submit | 1.0x (45.2ns) | 1.24x (56.0ns) | 1.08x (48.8ns) |
| 이벤트 publish | 1.0x (12.4ns) | 0.81x (10.0ns) | 1.05x (13.0ns) |

---

## 성능 분석

### Result<T>가 빠른 이유

1. **스택 할당**: 성공 케이스에서 힙 할당 없음
2. **모든 것 인라인**: 템플릿 함수 완전 인라인
3. **트리비얼 타입**: 트리비얼 복사/이동이 있는 POD 타입에 최적화
4. **컴파일러 최적화**: 데드 코드 제거가 사용되지 않는 경로 제거

### IExecutor 성능 특성

**태스크 제출 오버헤드 분석**:

| 컴포넌트 | 시간 (ns) | 비율 |
|----------|-----------|------|
| 람다 캡처 | 8.2 | 18% |
| std::function 생성 | 12.4 | 27% |
| 큐 삽입 | 18.6 | 41% |
| 동기화 | 6.0 | 13% |
| **합계** | **45.2** | **100%** |

---

## 대안과의 비교

### Result<T> vs 예외

| 시나리오 | Result<T> (ns) | 예외 (ns) | 속도 향상 |
|----------|----------------|-----------|-----------|
| 성공 경로 | 2.3 | 2.1 | 0.91x (비슷) |
| 오류 경로 (1단계) | 3.1 | 1,240 | **400x 빠름** |
| 오류 경로 (5단계) | 3.2 | 4,680 | **1,462x 빠름** |
| 오류 경로 (10단계) | 3.4 | 9,120 | **2,682x 빠름** |

**핵심 인사이트**: Result<T>는 호출 스택 깊이와 관계없이 일정 시간 오류 처리를 제공하는 반면, 예외는 스택 언와인딩에 따라 선형 비용이 발생합니다.

### IExecutor vs std::async

| 메트릭 | IExecutor (스레드 풀) | std::async |
|--------|----------------------|------------|
| 태스크 제출 | 45.2ns | 2,400ns |
| 처리량 | 22.1M 태스크/s | 0.4M 태스크/s |
| 스레드 생성 오버헤드 | 분산 | 태스크당 |
| 메모리 오버헤드 | 공유 풀 | 태스크당 |

**속도 향상**: IExecutor는 고빈도 태스크 제출에서 **53배 빠름**.

---

## 최적화 가이드라인

### Result<T> 사용 시기

✅ **Result<T>를 사용해야 하는 경우**:
- 오류 조건이 일반적 (케이스의 > 1%)
- 예외 오버헤드가 심각한 깊은 호출 스택
- 호출 사이트에서 명시적 오류 처리 필요
- 성능 예측 가능성이 중요 (예외 변동 없음)
- 함수형 합성 원함 (map/and_then)

### IExecutor 성능 팁

1. **결과가 필요 없을 때 `submit()` 대신 `execute()` 선호**
2. **제출 오버헤드 분산을 위해 배치 작업**
3. **스레드 풀 적정 크기 설정**:
   - CPU 바운드 태스크: `thread_count = hardware_concurrency()`
   - I/O 바운드 태스크: `thread_count = 2-4 * hardware_concurrency()`

### 메모리 최적화

1. **Result<T>와 함께 이동 시맨틱 사용**
2. **불필요한 Result<T> 복사 피하기**

---

**최종 업데이트**: 2025-11-28
**벤치마크 버전**: 1.0

---

Made with ❤️ by 🍀☀🌕🌥 🌊
