# Common System - ìƒì„¸ ê¸°ëŠ¥

**ì–¸ì–´:** [English](FEATURES.md) | **í•œêµ­ì–´**

ì´ ë¬¸ì„œëŠ” Common System í”„ë¡œì íŠ¸ì—ì„œ ì‚¬ìš© ê°€ëŠ¥í•œ ëª¨ë“  ê¸°ëŠ¥ì— ëŒ€í•œ í¬ê´„ì ì¸ ì„¸ë¶€ ì •ë³´ë¥¼ ì œê³µí•©ë‹ˆë‹¤.

---

## ëª©ì°¨

- [í•µì‹¬ ì¥ì  ë° ì´ì ](#í•µì‹¬-ì¥ì -ë°-ì´ì )
- [í•µì‹¬ ì»´í¬ë„ŒíŠ¸](#í•µì‹¬-ì»´í¬ë„ŒíŠ¸)
- [ë³µì›ë ¥ íŒ¨í„´](#ë³µì›ë ¥-íŒ¨í„´)
- [ì˜ì¡´ì„± ì£¼ì… ë° ë¶€íŠ¸ìŠ¤íŠ¸ë©](#ì˜ì¡´ì„±-ì£¼ì…-ë°-ë¶€íŠ¸ìŠ¤íŠ¸ë©)
- [í†µí•© ê¸°ëŠ¥](#í†µí•©-ê¸°ëŠ¥)
- [í”„ë¡œë•ì…˜ í’ˆì§ˆ ê¸°ëŠ¥](#í”„ë¡œë•ì…˜-í’ˆì§ˆ-ê¸°ëŠ¥)
- [ì˜¤ë¥˜ ì²˜ë¦¬ ê¸°ë°˜](#ì˜¤ë¥˜-ì²˜ë¦¬-ê¸°ë°˜)

---

## í•µì‹¬ ì¥ì  ë° ì´ì 

### ğŸš€ **ì„±ëŠ¥ ìš°ìˆ˜ì„±**

common_systemì€ ì—¬ëŸ¬ í•µì‹¬ ì„¤ê³„ ê²°ì •ì„ í†µí•´ ì œë¡œ ì˜¤ë²„í—¤ë“œ ì¶”ìƒí™”ë¥¼ ë‹¬ì„±í•©ë‹ˆë‹¤:

- **ì œë¡œ ì˜¤ë²„í—¤ë“œ ì¶”ìƒí™”**: ì»´íŒŒì¼ íƒ€ì„ í•´ì„ì„ í†µí•œ í…œí”Œë¦¿ ê¸°ë°˜ ì¸í„°í˜ì´ìŠ¤ë¡œ common_system ì¸í„°í˜ì´ìŠ¤ ì‚¬ìš©ì´ ì§ì ‘ ì‘ì„±í•œ ì½”ë“œì™€ ë¹„êµí•˜ì—¬ ëŸ°íƒ€ì„ ë¹„ìš©ì´ ì—†ìŒ
- **í—¤ë” ì „ìš© ì„¤ê³„**: ë¼ì´ë¸ŒëŸ¬ë¦¬ ë§í‚¹ì´ í•„ìš” ì—†ì–´ ì»´íŒŒì¼ëŸ¬ê°€ ìµœì í™”ë¥¼ ìœ„í•œ ì™„ì „í•œ ê°€ì‹œì„±ì„ ê°€ì§. ë” ë‚˜ì€ ì¸ë¼ì´ë‹, ë°ë“œ ì½”ë“œ ì œê±°, ë§í¬ íƒ€ì„ ìµœì í™” ê°€ëŠ¥
- **ìºì‹œ ì¹œí™”ì  íŒ¨í„´**: ìµœì†Œí•œì˜ ê°„ì ‘ ì°¸ì¡°ì™€ ìµœì ì˜ ë©”ëª¨ë¦¬ ë ˆì´ì•„ì›ƒìœ¼ë¡œ ìºì‹œ ë¯¸ìŠ¤ ê°ì†Œ ë° ì„±ëŠ¥ í–¥ìƒ
- **ì»´íŒŒì¼ íƒ€ì„ ìµœì í™”**: í•« íŒ¨ìŠ¤ì— ëŒ€í•œ ì™„ì „í•œ ì¸ë¼ì´ë‹ ì ì¬ë ¥ìœ¼ë¡œ ì»´íŒŒì¼ëŸ¬ê°€ ì¶”ìƒí™” ê²½ê³„ë¥¼ ë„˜ì–´ ìµœì í™” ê°€ëŠ¥

**ì„±ëŠ¥ ì˜í–¥:**
- í…œí”Œë¦¿ ì¸ìŠ¤í„´ìŠ¤í™”ëŠ” ì»´íŒŒì¼ íƒ€ì„ì— ë°œìƒí•˜ë©° ëŸ°íƒ€ì„ ì˜¤ë²„í—¤ë“œ ì—†ìŒ
- ì„±ëŠ¥ ì¤‘ìš” ê²½ë¡œì—ì„œ ê°€ìƒ í•¨ìˆ˜ í˜¸ì¶œ ì—†ìŒ
- ì»´íŒŒì¼ëŸ¬ê°€ ëª¨ë“  ì¶”ìƒí™” ë ˆì´ì–´ë¥¼ í†µí•´ ìµœì í™” ê°€ëŠ¥
- ë§í¬ íƒ€ì„ ìµœì í™”(LTO)ê°€ ëª¨ë“  ì¶”ìƒí™” ì˜¤ë²„í—¤ë“œ ì œê±° ê°€ëŠ¥

### ğŸ›¡ï¸ **í”„ë¡œë•ì…˜ ë“±ê¸‰ ì‹ ë¢°ì„±**

common_systemì˜ ëª¨ë“  ì¸í„°í˜ì´ìŠ¤ì™€ íŒ¨í„´ì€ í”„ë¡œë•ì…˜ ì‹ ë¢°ì„±ì„ ê³ ë ¤í•˜ì—¬ ì„¤ê³„ë˜ì—ˆìŠµë‹ˆë‹¤:

- **íƒ€ì… ì•ˆì „ ì¸í„°í˜ì´ìŠ¤**: ì»´íŒŒì¼ íƒ€ì„ì— ì‹¤ìˆ˜ë¥¼ í¬ì°©í•˜ì—¬ ì¼ë°˜ì ì¸ ëŸ°íƒ€ì„ ì˜¤ë¥˜ ë°©ì§€
  - í…œí”Œë¦¿ ì œì•½ì´ ì˜¬ë°”ë¥¸ ì‚¬ìš© ê°•ì œ
  - ì»´íŒŒì¼ íƒ€ì„ ê²€ì‚¬ê°€ ì˜¤ìš© ë°©ì§€
  - ì•ˆì „í•˜ì§€ ì•Šì€ ìºìŠ¤íŠ¸ë‚˜ íƒ€ì… ì†Œê±° ì—†ìŒ

- **Result<T> íŒ¨í„´**: ì˜ˆì™¸ ì—†ì´ ëª…ì‹œì  ì˜¤ë¥˜ ì²˜ë¦¬
  - í˜¸ì¶œ ì‚¬ì´íŠ¸ì—ì„œ ì˜¤ë¥˜ ì²˜ë¦¬ ê°•ì œ
  - ì˜ˆì™¸ë¡œ ì¸í•œ ìˆ¨ê²¨ì§„ ì œì–´ íë¦„ ì—†ìŒ
  - ëª…í™•í•œ ì˜¤ë¥˜ ì „íŒŒ ê²½ë¡œ
  - ì˜¤ë¥˜ê°€ ë°œìƒí•˜ì§€ ì•Šì„ ë•Œ ì œë¡œ ë¹„ìš©

- **RAII ì¤€ìˆ˜**: í‘œì¤€ íŒ¨í„´ì„ í†µí•œ ë¦¬ì†ŒìŠ¤ ê´€ë¦¬
  - ëª¨ë“  ë¦¬ì†ŒìŠ¤ê°€ ìŠ¤ë§ˆíŠ¸ í¬ì¸í„° ì‚¬ìš©
  - ìŠ¤ì½”í”„ ì¢…ë£Œ ì‹œ ìë™ ì •ë¦¬
  - ì„¤ê³„ìƒ ì˜ˆì™¸ ì•ˆì „
  - ìˆ˜ë™ ë©”ëª¨ë¦¬ ê´€ë¦¬ ì—†ìŒ

- **ìŠ¤ë ˆë“œ ì•ˆì „ ì„¤ê³„**: ëª¨ë“  ì¸í„°í˜ì´ìŠ¤ê°€ ë™ì‹œ ì‚¬ìš©ì— ì•ˆì „
  - ê°€ëŠ¥í•œ ê²½ìš° ë¶ˆë³€ íƒ€ì…
  - ëª…í™•í•œ ë™ì‹œì„± ë³´ì¥
  - ì ì ˆí•œ ê²½ìš° ë½í”„ë¦¬ ì•Œê³ ë¦¬ì¦˜
  - ì„¤ê³„ìƒ ë°ì´í„° ë ˆì´ìŠ¤ ì—†ìŒ

### ğŸ”§ **ê°œë°œì ìƒì‚°ì„±**

Common_systemì€ ê°œë°œì ê²½í—˜ê³¼ ìƒì‚°ì„±ì„ ìš°ì„ ì‹œí•©ë‹ˆë‹¤:

- **ìì²´ ë¬¸ì„œí™” ì¸í„°í˜ì´ìŠ¤**: í¬ê´„ì ì¸ ë¬¸ì„œì™€ í•¨ê»˜ ëª…í™•í•œ ê³„ì•½
  - í‘œí˜„ë ¥ ìˆëŠ” íƒ€ì… ì´ë¦„
  - í¬ê´„ì ì¸ Doxygen ì£¼ì„
  - í—¤ë”ì˜ ì‚¬ìš© ì˜ˆì œ
  - ëª…í™•í•œ ì˜¤ë¥˜ ë©”ì‹œì§€

- **ìµœì†Œ ë³´ì¼ëŸ¬í”Œë ˆì´íŠ¸**: ê¹”ë”í•œ API ì„¤ê³„ë¡œ ì½”ë“œ ì˜¤ë²„í—¤ë“œ ê°ì†Œ
  - ì¼ë°˜ì ì¸ íŒ¨í„´ì„ ìœ„í•œ í”Œë£¨ì–¸íŠ¸ ì¸í„°í˜ì´ìŠ¤
  - ì¥í™©í•¨ì„ ì¤„ì´ëŠ” íƒ€ì… ì¶”ë¡ 
  - í•©ë¦¬ì ì¸ ê¸°ë³¸ê°’
  - ì¼ë°˜ì ì¸ ì‚¬ìš© ì‚¬ë¡€ë¥¼ ìœ„í•œ í—¬í¼ í•¨ìˆ˜

- **ëª¨í‚¹ ê°€ëŠ¥í•œ ì¶”ìƒí™”**: ì¸í„°í˜ì´ìŠ¤ ì£¼ì…ì„ í†µí•œ ì‰¬ìš´ í…ŒìŠ¤íŒ…
  - ìˆœìˆ˜ ê°€ìƒ ì¸í„°í˜ì´ìŠ¤
  - ì˜ì¡´ì„± ì£¼ì… ì¹œí™”ì 
  - ëª¨ì˜ êµ¬í˜„ í¬í•¨
  - í…ŒìŠ¤íŠ¸ í—¬í¼ ì œê³µ

- **IDE ì¹œí™”ì **: ì™„ì „í•œ IntelliSense ë° ìë™ ì™„ì„± ì§€ì›
  - ì™„ì „í•œ íƒ€ì… ì •ë³´
  - í…œí”Œë¦¿ ì¸ìŠ¤í„´ìŠ¤í™” íŒíŠ¸
  - ì •ì˜ë¡œ ì´ë™ ì‘ë™
  - ë¦¬íŒ©í† ë§ ë„êµ¬ í˜¸í™˜

### ğŸŒ **ë²”ìš© í˜¸í™˜ì„±**

ëª¨ë“  í˜„ëŒ€ C++ í™˜ê²½ì—ì„œ ì‘ë™í•˜ë„ë¡ ì„¤ê³„ë˜ì—ˆìŠµë‹ˆë‹¤:

- **C++17 í‘œì¤€**: ë” ë„“ì€ ì»´íŒŒì¼ëŸ¬ ì§€ì›ìœ¼ë¡œ í•˜ìœ„ í˜¸í™˜ì„±
  - GCC 7+ (7, 9, 11, 13ì—ì„œ í…ŒìŠ¤íŠ¸ë¨)
  - Clang 5+ (5, 10, 14, 16ì—ì„œ í…ŒìŠ¤íŠ¸ë¨)
  - MSVC 2017+ (2017, 2019, 2022ì—ì„œ í…ŒìŠ¤íŠ¸ë¨)
  - ì»´íŒŒì¼ëŸ¬ íŠ¹ì • í™•ì¥ í•„ìš” ì—†ìŒ

- **C++20 ê¸°ëŠ¥**: ì‚¬ìš© ê°€ëŠ¥í•œ ê²½ìš° í–¥ìƒëœ ê¸°ëŠ¥ì„ ìœ„í•œ ì„ íƒì  ì§€ì›
  - ë” ë‚˜ì€ ì˜¤ë¥˜ ì§„ë‹¨ì„ ìœ„í•œ `std::source_location`
  - ë” ëª…í™•í•œ í…œí”Œë¦¿ ì œì•½ì„ ìœ„í•œ Concepts
  - C++17 ë“±ê°€ë¬¼ë¡œì˜ ìš°ì•„í•œ í´ë°±

- **í¬ë¡œìŠ¤ í”Œë«í¼**: ìˆ˜ì • ì—†ì´ Windows, Linux, macOS
  - í”Œë«í¼ì— êµ¬ì• ë°›ì§€ ì•ŠëŠ” ì¸í„°í˜ì´ìŠ¤
  - í—¤ë”ì— OS íŠ¹ì • ì½”ë“œ ì—†ìŒ
  - í”Œë«í¼ ê°„ ì¼ê´€ëœ ë™ì‘
  - ëª¨ë“  ì£¼ìš” í”Œë«í¼ì—ì„œ CI í…ŒìŠ¤íŒ…

- **ë¹Œë“œ ì‹œìŠ¤í…œ ë…ë¦½**: ëª¨ë“  ë¹Œë“œ ì‹œìŠ¤í…œê³¼ ì‘ë™
  - CMake í†µí•© ì œê³µ
  - Bazel ì§€ì› ê°€ëŠ¥
  - ì¼ë°˜ Make í˜¸í™˜
  - í—¤ë” ì „ìš©ì´ë¯€ë¡œ ë¹Œë“œ í•„ìš” ì—†ìŒ

### ğŸ“ˆ **ì—”í„°í”„ë¼ì´ì¦ˆ ì¤€ë¹„ ê¸°ëŠ¥**

ëŒ€ê·œëª¨ ì—”í„°í”„ë¼ì´ì¦ˆ ë°°í¬ë¥¼ ìœ„í•´ êµ¬ì¶•ë¨:

- **ì¸í„°í˜ì´ìŠ¤ ë²„ì „ ê´€ë¦¬**: ì‹ ì¤‘í•œ ì„¤ê³„ë¥¼ í†µí•œ í•˜ìœ„ í˜¸í™˜ì„±
  - ì»´íŒŒì¼ íƒ€ì„ì— ABI ë²„ì „ ê²€ì‚¬
  - ì¸í„°í˜ì´ìŠ¤ì˜ ì‹œë§¨í‹± ë²„ì „ ê´€ë¦¬
  - ì´ì „ APIì— ëŒ€í•œ ì‚¬ìš© ì¤‘ë‹¨ ê²½ê³ 
  - ë§ˆì´ê·¸ë ˆì´ì…˜ ê°€ì´ë“œ ì œê³µ

- **ì¤‘ì•™ ì§‘ì¤‘ì‹ êµ¬ì„±**: ëª¨ë“  ëª¨ë“ˆì— ê±¸ì³ í†µí•©ëœ ë¹Œë“œ í”Œë˜ê·¸
  - ì„ íƒì  ì»´í¬ë„ŒíŠ¸ë¥¼ ìœ„í•œ ê¸°ëŠ¥ í”Œë˜ê·¸
  - ì¼ê´€ëœ ë¹Œë“œ êµ¬ì„±
  - ì‚¬ìš©ì ì •ì˜ë¥¼ ìœ„í•œ ì¬ì •ì˜ í¬ì¸íŠ¸
  - êµ¬ì„± ìœ íš¨ì„± ê²€ì‚¬

- **í¬ê´„ì ì¸ í…ŒìŠ¤íŒ…**: ì—…ê³„ í‘œì¤€ í”„ë ˆì„ì›Œí¬ë¡œ ì™„ì „í•œ í…ŒìŠ¤íŠ¸ ì»¤ë²„ë¦¬ì§€
  - Google Testë¡œ ìœ ë‹› í…ŒìŠ¤íŠ¸
  - ì‹¤ì œ ì»´í¬ë„ŒíŠ¸ë¡œ í†µí•© í…ŒìŠ¤íŠ¸
  - ì„±ëŠ¥ ê²€ì¦ì„ ìœ„í•œ ë²¤ì¹˜ë§ˆí¬ í…ŒìŠ¤íŠ¸
  - ìƒˆë‹ˆíƒ€ì´ì € ì»¤ë²„ë¦¬ì§€ (ASan, TSan, UBSan)

---

## í•µì‹¬ ì»´í¬ë„ŒíŠ¸

### IExecutor ì¸í„°í˜ì´ìŠ¤

IExecutor ì¸í„°í˜ì´ìŠ¤ëŠ” íƒœìŠ¤í¬ ì‹¤í–‰ì„ ìœ„í•œ ë²”ìš© ì¶”ìƒí™”ë¥¼ ì œê³µí•˜ì—¬ íŠ¹ì • ìŠ¤ë ˆë”© êµ¬í˜„ìœ¼ë¡œë¶€í„° ì™„ì „í•œ ë…ë¦½ì„±ì„ ê°€ëŠ¥í•˜ê²Œ í•©ë‹ˆë‹¤.

**ì£¼ìš” ê¸°ëŠ¥:**

- **ìŠ¤ë ˆë”© ë°±ì—”ë“œ ë…ë¦½ì„±**: í•œ ë²ˆ ì‘ì„±í•˜ê³  ëª¨ë“  ì‹¤í–‰ê¸°ì—ì„œ ì‹¤í–‰
- **íƒœìŠ¤í¬ ê¸°ë°˜ ì¶”ìƒí™”**: ëŒë‹¤ í•¨ìˆ˜, í•¨ìˆ˜ ê°ì²´ ë˜ëŠ” std::function ì œì¶œ
- **Future ê¸°ë°˜ ê²°ê³¼**: std::future<T>ë¥¼ í†µí•œ íƒ€ì… ì•ˆì „ ë¹„ë™ê¸° ê²°ê³¼
- **ì˜ˆì™¸ ì•ˆì „ì„±**: futureë¥¼ í†µí•´ ì˜ˆì™¸ ì „íŒŒ
- **ìˆ˜ëª… ê´€ë¦¬**: RAIIë¥¼ í†µí•œ ìë™ ì •ë¦¬

**ì¸í„°í˜ì´ìŠ¤ ë©”ì„œë“œ:**

```cpp
namespace kcenon::common::interfaces {
    class IExecutor {
    public:
        virtual ~IExecutor() = default;

        // íƒœìŠ¤í¬ë¥¼ ì œì¶œí•˜ê³  ê²°ê³¼ì— ëŒ€í•œ future ë°˜í™˜
        template<typename F, typename... Args>
        auto submit(F&& func, Args&&... args)
            -> std::future<std::invoke_result_t<F, Args...>>;

        // ê²°ê³¼ ë°˜í™˜ ì—†ì´ íƒœìŠ¤í¬ ì‹¤í–‰
        template<typename F, typename... Args>
        void execute(F&& func, Args&&... args);

        // ì‹¤í–‰ê¸° ì •ë³´ ì¡°íšŒ
        virtual size_t thread_count() const = 0;
        virtual bool is_running() const = 0;
    };
}
```

**ì‚¬ìš© íŒ¨í„´:**

1. **Fire and forget ì‹¤í–‰**:
```cpp
executor->execute([]() {
    // ë°±ê·¸ë¼ìš´ë“œ íƒœìŠ¤í¬
    process_data();
});
```

2. **ê²°ê³¼ê°€ ìˆëŠ” ë¹„ë™ê¸°**:
```cpp
auto future = executor->submit([]() {
    return compute_value();
});
auto result = future.get();
```

3. **ë¹„ë™ê¸° ì‘ì—… ì²´ì´ë‹**:
```cpp
auto future1 = executor->submit(load_data);
auto future2 = executor->submit([future1 = std::move(future1)]() mutable {
    auto data = future1.get();
    return process(data);
});
```

**í†µí•©:**

IExecutor ì¸í„°í˜ì´ìŠ¤ëŠ” ë‹¤ìŒì— ì˜í•´ êµ¬í˜„ë©ë‹ˆë‹¤:
- ì–´ëŒ‘í„° íŒ¨í„´ì„ í†µí•œ `thread_system::thread_pool`
- ë¹„ë™ê¸° I/O ì‘ì—…ì„ ìœ„í•œ `network_system`
- íŠ¹ìˆ˜ ì‹¤í–‰ê¸°ë¥¼ ìœ„í•œ ì»¤ìŠ¤í…€ êµ¬í˜„

### Result<T> íŒ¨í„´

ì˜ˆì™¸ ì—†ì´ íƒ€ì… ì•ˆì „ ì˜¤ë¥˜ ì²˜ë¦¬ë¥¼ ìœ„í•œ Result ëª¨ë‚˜ë“œ íŒ¨í„´ì˜ í¬ê´„ì ì¸ êµ¬í˜„ì…ë‹ˆë‹¤.

**ì„¤ê³„ ì² í•™:**

- ëª¨ë“  í˜¸ì¶œ ì‚¬ì´íŠ¸ì—ì„œ ëª…ì‹œì  ì˜¤ë¥˜ ì²˜ë¦¬
- ì˜ˆì™¸ë¡œ ì¸í•œ ìˆ¨ê²¨ì§„ ì œì–´ íë¦„ ì—†ìŒ
- ëª¨ë‚˜ë”• ì—°ì‚°ì„ í†µí•œ í•¨ìˆ˜í˜• í•©ì„±
- ì„±ê³µ ì‹œ ì œë¡œ ì˜¤ë²„í—¤ë“œ
- ì»´íŒŒì¼ íƒ€ì„ì— ì™„ì „í•œ íƒ€ì… ì•ˆì „ì„±

**í•µì‹¬ ì—°ì‚°:**

```cpp
namespace kcenon::common {
    template<typename T>
    class Result {
    public:
        // íŒ©í† ë¦¬ ë©”ì„œë“œ
        static Result<T> ok(T value);
        static Result<T> error(ErrorInfo info);

        // ìƒíƒœ ì¿¼ë¦¬
        bool is_ok() const noexcept;
        bool is_error() const noexcept;
        explicit operator bool() const noexcept;

        // ê°’ ì ‘ê·¼ (ì˜¤ë¥˜ ì‹œ throw)
        T& value() &;
        const T& value() const &;
        T&& value() &&;

        // ê°’ ë˜ëŠ” ê¸°ë³¸ê°’ ì ‘ê·¼
        T value_or(T&& default_value) const&;
        T value_or(T&& default_value) &&;

        // ì˜¤ë¥˜ ì ‘ê·¼
        const ErrorInfo& error() const;

        // ëª¨ë‚˜ë”• ì—°ì‚°
        template<typename F>
        auto map(F&& func) const& -> Result<std::invoke_result_t<F, const T&>>;

        template<typename F>
        auto and_then(F&& func) const& -> std::invoke_result_t<F, const T&>;

        template<typename F>
        auto or_else(F&& func) const& -> Result<T>;
    };
}
```

**ëª¨ë‚˜ë”• í•©ì„±:**

Result<T> íŒ¨í„´ì€ í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë° íŒ¨ëŸ¬ë‹¤ì„ì„ ì§€ì›í•©ë‹ˆë‹¤:

```cpp
// Map: ì„±ê³µ ê°’ ë³€í™˜
auto result = load_config("app.conf")
    .map([](const Config& cfg) {
        return cfg.with_defaults();
    });

// AndThen: Resultë¥¼ ë°˜í™˜í•˜ëŠ” ì‘ì—… ì²´ì´ë‹
auto result = load_config("app.conf")
    .and_then(validate_config)
    .and_then(apply_schema);

// OrElse: ì˜¤ë¥˜ ì‹œ í´ë°± ì œê³µ
auto result = load_config("app.conf")
    .or_else([](const ErrorInfo& err) {
        log_error(err);
        return load_default_config();
    });

// ì „ì²´ í•©ì„±
auto result = load_config("app.conf")
    .and_then(validate_config)
    .map(apply_defaults)
    .and_then(connect_to_db)
    .or_else(use_fallback_db);
```

**ì˜¤ë¥˜ ì»¨í…ìŠ¤íŠ¸:**

í’ë¶€í•œ ì˜¤ë¥˜ ì •ë³´ í¬í•¨:

```cpp
struct ErrorInfo {
    int code;                    // ë ˆì§€ìŠ¤íŠ¸ë¦¬ì˜ ì˜¤ë¥˜ ì½”ë“œ
    std::string message;         // ì‚¬ëŒì´ ì½ì„ ìˆ˜ ìˆëŠ” ë©”ì‹œì§€
    std::string source;          // ì†ŒìŠ¤ ëª¨ë“ˆ/í•¨ìˆ˜
    std::string file;            // ì†ŒìŠ¤ íŒŒì¼ (ê°€ëŠ¥í•œ ê²½ìš°)
    int line;                    // ì†ŒìŠ¤ ë¼ì¸ (ê°€ëŠ¥í•œ ê²½ìš°)
    std::optional<std::string>
        additional_context;      // ì¶”ê°€ ì»¨í…ìŠ¤íŠ¸
};
```

---

## ë³µì›ë ¥ íŒ¨í„´

`kcenon::common::resilience` ë„¤ì„ìŠ¤í˜ì´ìŠ¤ëŠ” ë¶„ì‚° ì‹œìŠ¤í…œì„ ìœ„í•œ í”„ë¡œë•ì…˜ ë“±ê¸‰ ì¥ì•  í—ˆìš© í”„ë¦¬ë¯¸í‹°ë¸Œë¥¼ ì œê³µí•©ë‹ˆë‹¤. ëª¨ë“  ë³µì›ë ¥ ì»´í¬ë„ŒíŠ¸ì— ì ‘ê·¼í•˜ë ¤ë©´ ìš°ì‚° í—¤ë” `<kcenon/common/resilience/resilience.h>`ë¥¼ í¬í•¨í•˜ì„¸ìš”.

### ì„œí‚· ë¸Œë ˆì´ì»¤

ì„œí‚· ë¸Œë ˆì´ì»¤ íŒ¨í„´ì€ ì¥ì• ê°€ ë°œìƒí•œ ì„œë¹„ìŠ¤ì— ëŒ€í•œ ìš”ì²­ì„ ì¼ì‹œì ìœ¼ë¡œ ì°¨ë‹¨í•˜ì—¬ ì—°ì‡„ ì¥ì• ë¥¼ ë°©ì§€í•˜ê³ , ì„œë¹„ìŠ¤ê°€ ë³µêµ¬í•  ì‹œê°„ì„ ì œê³µí•©ë‹ˆë‹¤.

**ìƒíƒœ ë¨¸ì‹ :**

```
CLOSED â”€â”€(ì‹¤íŒ¨ ì„ê³„ê°’ ì´ˆê³¼)â”€â”€â–º OPEN
  â–²                              â”‚
  â”‚                              â”‚ (íƒ€ì„ì•„ì›ƒ ë§Œë£Œ)
  â”‚                              â–¼
  â””â”€â”€(ì„±ê³µ ì„ê³„ê°’ ë‹¬ì„±)â”€â”€â”€â”€ HALF_OPEN
                               â”‚
                               â””â”€â”€(ì‹¤íŒ¨ ë°œìƒ)â”€â”€â–º OPEN
```

| ìƒíƒœ | ë™ì‘ |
|------|------|
| `CLOSED` | ì •ìƒ ì‘ë™. ìš”ì²­ì´ í†µê³¼í•˜ë©°, ì‹¤íŒ¨ê°€ ìŠ¬ë¼ì´ë”© íƒ€ì„ ìœˆë„ìš° ë‚´ì—ì„œ ì¶”ì ë¨. |
| `OPEN` | ì‹¤íŒ¨ ì„ê³„ê°’ ì´ˆê³¼. ëª¨ë“  ìš”ì²­ì´ ì¦‰ì‹œ ê±°ë¶€ë¨. íƒ€ì„ì•„ì›ƒ í›„ `HALF_OPEN`ìœ¼ë¡œ ì „í™˜. |
| `HALF_OPEN` | ë³µêµ¬ í…ŒìŠ¤íŠ¸. ì œí•œëœ ìˆ˜ì˜ í”„ë¡œë¸Œ ìš”ì²­ì´ í—ˆìš©ë¨. ì„±ê³µ ì‹œ íšŒë¡œë¥¼ ë‹«ê³ , ì‹¤íŒ¨ ì‹œ ë‹¤ì‹œ ì—´ë¦¼. |

**ì„¤ì • (`circuit_breaker_config`):**

```cpp
namespace kcenon::common::resilience {

struct circuit_breaker_config {
    // íšŒë¡œë¥¼ íŠ¸ë¦½í•˜ê¸° ìœ„í•œ ì‹¤íŒ¨ íšŸìˆ˜ (CLOSED -> OPEN)
    std::size_t failure_threshold = 5;

    // íšŒë¡œë¥¼ ë‹«ê¸° ìœ„í•œ ì„±ê³µ íšŸìˆ˜ (HALF_OPEN -> CLOSED)
    std::size_t success_threshold = 2;

    // ì‹¤íŒ¨ ì¶”ì ì„ ìœ„í•œ ìŠ¬ë¼ì´ë”© íƒ€ì„ ìœˆë„ìš° (ìœˆë„ìš° ë°–ì˜ ì‹¤íŒ¨ëŠ” ë§Œë£Œ)
    std::chrono::milliseconds failure_window = std::chrono::seconds(60);

    // OPENì—ì„œ HALF_OPENìœ¼ë¡œ ì „í™˜í•˜ê¸° ì „ ì¿¨ë‹¤ìš´
    std::chrono::milliseconds timeout = std::chrono::seconds(30);

    // HALF_OPEN ìƒíƒœì—ì„œ í—ˆìš©ë˜ëŠ” ìµœëŒ€ í”„ë¡œë¸Œ ìš”ì²­ ìˆ˜
    std::size_t half_open_max_requests = 3;
};

}
```

**í•µì‹¬ API (`circuit_breaker`):**

```cpp
namespace kcenon::common::resilience {

class circuit_breaker : public interfaces::IStats {
public:
    explicit circuit_breaker(circuit_breaker_config config = {});

    // ìš”ì²­ í—ˆìš© ì—¬ë¶€ í™•ì¸
    [[nodiscard]] auto allow_request() -> bool;

    // ì‘ì—… ê²°ê³¼ ê¸°ë¡
    auto record_success() -> void;
    auto record_failure(const std::exception* e = nullptr) -> void;

    // í˜„ì¬ ìƒíƒœ ì¡°íšŒ
    [[nodiscard]] auto get_state() const -> circuit_state;

    // RAII ê°€ë“œë¡œ ìë™ ì„±ê³µ/ì‹¤íŒ¨ ê¸°ë¡
    [[nodiscard]] auto make_guard() -> guard;

    // IStats ì¸í„°í˜ì´ìŠ¤ - ê´€ì°° ê°€ëŠ¥ì„±
    [[nodiscard]] auto get_stats() const
        -> std::unordered_map<std::string, interfaces::stats_value> override;
    [[nodiscard]] auto to_json() const -> std::string override;
    [[nodiscard]] auto name() const -> std::string_view override;
};

}
```

**RAII ê°€ë“œ:**

`circuit_breaker::guard` í´ë˜ìŠ¤ëŠ” `record_success()`ê°€ ëª…ì‹œì ìœ¼ë¡œ í˜¸ì¶œë˜ì§€ ì•Šìœ¼ë©´ ì†Œë©¸ ì‹œ ìë™ìœ¼ë¡œ ì‹¤íŒ¨ë¥¼ ê¸°ë¡í•©ë‹ˆë‹¤. ì´ë¥¼ í†µí•´ ì˜ˆì™¸ë¥¼ ë°œìƒì‹œí‚¤ëŠ” ì‘ì—…ì´ ì˜¬ë°”ë¥´ê²Œ ì¶”ì ë©ë‹ˆë‹¤.

```cpp
class circuit_breaker::guard {
public:
    explicit guard(circuit_breaker& breaker);
    ~guard();  // record_success()ê°€ í˜¸ì¶œë˜ì§€ ì•Šì•˜ìœ¼ë©´ ì‹¤íŒ¨ ê¸°ë¡

    auto record_success() -> void;

    // ë³µì‚¬ ë¶ˆê°€, ì´ë™ ë¶ˆê°€
    guard(const guard&) = delete;
    guard& operator=(const guard&) = delete;
};
```

**ì‚¬ìš© ì˜ˆì œ:**

```cpp
#include <kcenon/common/resilience/resilience.h>

using namespace kcenon::common::resilience;

// ë¸Œë ˆì´ì»¤ ì„¤ì •
circuit_breaker_config config{
    .failure_threshold = 5,
    .success_threshold = 2,
    .failure_window = std::chrono::seconds(60),
    .timeout = std::chrono::seconds(30),
    .half_open_max_requests = 3
};
circuit_breaker breaker(config);

// íŒ¨í„´ 1: ìˆ˜ë™ í™•ì¸ ë° ê¸°ë¡
if (!breaker.allow_request()) {
    return make_error("Service unavailable - circuit is open");
}
try {
    auto result = call_remote_service();
    breaker.record_success();
    return result;
} catch (const std::exception& e) {
    breaker.record_failure(&e);
    throw;
}

// íŒ¨í„´ 2: RAII ê°€ë“œ (ê¶Œì¥)
if (breaker.allow_request()) {
    auto guard = breaker.make_guard();
    auto result = call_remote_service();
    guard.record_success();  // ìë™ ì‹¤íŒ¨ ê¸°ë¡ ë°©ì§€
    return result;
}
// call_remote_service()ê°€ ì˜ˆì™¸ë¥¼ ë°œìƒì‹œí‚¤ë©´ ~guard()ê°€ ìë™ìœ¼ë¡œ ì‹¤íŒ¨ ê¸°ë¡
```

**ê´€ì°° ê°€ëŠ¥ì„±:**

ì„œí‚· ë¸Œë ˆì´ì»¤ëŠ” `IStats`ë¥¼ êµ¬í˜„í•˜ì—¬ ì‹¤ì‹œê°„ ë©”íŠ¸ë¦­ì„ ì œê³µí•©ë‹ˆë‹¤:

```cpp
auto stats = breaker.get_stats();
// ë°˜í™˜: current_state, failure_count, consecutive_successes,
//       half_open_requests, failure_threshold, is_open

auto json = breaker.to_json();
// ëª¨ë“  í†µê³„ì˜ JSON í‘œí˜„ ë°˜í™˜
```

**ì‹¤íŒ¨ ìœˆë„ìš°:**

`failure_window` í´ë˜ìŠ¤ëŠ” ì‹¤íŒ¨ ì¶”ì ì„ ìœ„í•œ ìŠ¬ë¼ì´ë”© íƒ€ì„ ìœˆë„ìš°ë¥¼ ì œê³µí•©ë‹ˆë‹¤. ì„¤ì •ëœ `failure_window` ê¸°ê°„ë³´ë‹¤ ì˜¤ë˜ëœ ì‹¤íŒ¨ëŠ” ìë™ìœ¼ë¡œ ë§Œë£Œë˜ì–´ ì„ê³„ê°’ ê³„ì‚°ì— í¬í•¨ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.

**ìŠ¤ë ˆë“œ ì•ˆì „ì„±:**
- `circuit_breaker`ì™€ `failure_window`ì˜ ëª¨ë“  public ë©”ì„œë“œëŠ” ìŠ¤ë ˆë“œ ì•ˆì „í•©ë‹ˆë‹¤.
- ìƒíƒœ ì „í™˜ì€ ë‚´ë¶€ ë™ê¸°í™”ë¡œ ë³´í˜¸ë©ë‹ˆë‹¤.
- ì—¬ëŸ¬ ìŠ¤ë ˆë“œì—ì„œ ë™ì‹œ ì ‘ê·¼ ì•ˆì „í•©ë‹ˆë‹¤.

---

## ì˜ì¡´ì„± ì£¼ì… ë° ë¶€íŠ¸ìŠ¤íŠ¸ë©

common_systemì€ ì„œë¹„ìŠ¤ ìˆ˜ëª… ê´€ë¦¬, ì˜ì¡´ì„± ì—°ê²°, ì• í”Œë¦¬ì¼€ì´ì…˜ ìƒëª…ì£¼ê¸° ì œì–´ë¥¼ ìœ„í•œ ì˜ì¡´ì„± ì£¼ì…(DI) ì»¨í…Œì´ë„ˆì™€ ë¶€íŠ¸ìŠ¤íŠ¸ë˜í•‘ ìœ í‹¸ë¦¬í‹°ë¥¼ ì œê³µí•©ë‹ˆë‹¤.

### ì„œë¹„ìŠ¤ ì»¨í…Œì´ë„ˆ

`service_container` (`kcenon::common::di`)ëŠ” íŒ©í† ë¦¬ ê¸°ë°˜ ë“±ë¡, ë‹¤ì¤‘ ìˆ˜ëª… ì •ì±…, ìŠ¤ì½”í”„ ì»¨í…Œì´ë„ˆ, ìˆœí™˜ ì˜ì¡´ì„± ê°ì§€ë¥¼ ì§€ì›í•˜ëŠ” ìŠ¤ë ˆë“œ ì•ˆì „ DI ì»¨í…Œì´ë„ˆì…ë‹ˆë‹¤.

**ì„œë¹„ìŠ¤ ìˆ˜ëª… (`service_lifetime`):**

| ìˆ˜ëª… | ë™ì‘ | ì‚¬ìš© ì‚¬ë¡€ |
|------|------|----------|
| `singleton` | ì „ì—­ì ìœ¼ë¡œ ê³µìœ ë˜ëŠ” í•˜ë‚˜ì˜ ì¸ìŠ¤í„´ìŠ¤; ì²« ë²ˆì§¸ í•´ì„ ì‹œ ìƒì„±. | ë¡œê±°, ì„¤ì •, ìƒíƒœ ì—†ëŠ” ì„œë¹„ìŠ¤. |
| `transient` | ëª¨ë“  í•´ì„ ìš”ì²­ë§ˆë‹¤ ìƒˆ ì¸ìŠ¤í„´ìŠ¤ ìƒì„±. | ì†Œë¹„ìë³„ ìƒíƒœ ë³´ìœ  ì„œë¹„ìŠ¤. |
| `scoped` | `IServiceScope`ë‹¹ í•˜ë‚˜ì˜ ì¸ìŠ¤í„´ìŠ¤; í•´ë‹¹ ìŠ¤ì½”í”„ ë‚´ì—ì„œ ê³µìœ . | ìš”ì²­ ë²”ìœ„ ì„œë¹„ìŠ¤, ì‘ì—… ë‹¨ìœ„ íŒ¨í„´. |

**ë“±ë¡ API:**

```cpp
auto& container = service_container::global();

// êµ¬í˜„ íƒ€ì… ë“±ë¡ (ê¸°ë³¸ ìƒì„± ê°€ëŠ¥)
container.register_type<ILogger, ConsoleLogger>(service_lifetime::singleton);

// ì˜ì¡´ì„± í•´ì„ì´ í¬í•¨ëœ íŒ©í† ë¦¬ ë“±ë¡
container.register_factory<IDatabase>(
    [](IServiceContainer& c) {
        auto logger = c.resolve<ILogger>().value();
        return std::make_shared<PostgresDatabase>(logger);
    },
    service_lifetime::scoped
);

// ë‹¨ìˆœ íŒ©í† ë¦¬ ë“±ë¡ (ì»¨í…Œì´ë„ˆ ì ‘ê·¼ ë¶ˆí•„ìš”)
container.register_simple_factory<ICache>(
    [] { return std::make_shared<InMemoryCache>(); },
    service_lifetime::singleton
);

// ê¸°ì¡´ ì¸ìŠ¤í„´ìŠ¤ ë“±ë¡
auto config = std::make_shared<AppConfig>("config.yaml");
container.register_instance<IConfig>(config);
```

**í•´ì„ API:**

```cpp
// ì˜¤ë¥˜ ì²˜ë¦¬ì™€ í•¨ê»˜ í•´ì„
auto result = container.resolve<ILogger>();
if (result.is_ok()) {
    auto logger = result.value();
    logger->info("Resolved successfully");
}

// nullptr ë°˜í™˜ìœ¼ë¡œ í•´ì„ (ì„ íƒì  ì„œë¹„ìŠ¤ìš©)
auto cache = container.resolve_or_null<ICache>();
if (cache) {
    cache->set("key", "value");
}

// ì¸íŠ¸ë¡œìŠ¤í™ì…˜
bool has_logger = container.is_registered<ILogger>();
auto services = container.registered_services();
```

**ìŠ¤ì½”í”„ ì»¨í…Œì´ë„ˆ:**

ìŠ¤ì½”í”„ëŠ” ì‹±ê¸€í†¤ì„ ë¶€ëª¨ì™€ ê³µìœ í•˜ë©´ì„œ ìŠ¤ì½”í”„ ì„œë¹„ìŠ¤ì— ëŒ€í•œ ìš”ì²­ ìˆ˜ì¤€ ê²©ë¦¬ë¥¼ ì œê³µí•©ë‹ˆë‹¤:

```cpp
auto& container = service_container::global();

void handle_request() {
    auto scope = container.create_scope();

    // ê° ìŠ¤ì½”í”„ê°€ ìì²´ IDatabase ì¸ìŠ¤í„´ìŠ¤ë¥¼ ê°€ì§
    auto db = scope->resolve<IDatabase>().value();
    auto db2 = scope->resolve<IDatabase>().value();
    // db == db2 (ì´ ìŠ¤ì½”í”„ ë‚´ì—ì„œ ë™ì¼í•œ ìŠ¤ì½”í”„ ì¸ìŠ¤í„´ìŠ¤)

    // ì‹±ê¸€í†¤ì€ ë¶€ëª¨ì™€ ê³µìœ 
    auto logger = scope->resolve<ILogger>().value();
    // ë¶€ëª¨ ì»¨í…Œì´ë„ˆì™€ ë™ì¼í•œ ILogger ì¸ìŠ¤í„´ìŠ¤

} // ìŠ¤ì½”í”„ ì†Œë©¸, ìŠ¤ì½”í”„ ì¸ìŠ¤í„´ìŠ¤ í•´ì œ
```

**ë³´ì•ˆ ì œì–´:**

```cpp
// ì´ˆê¸°í™” í›„ ì»¨í…Œì´ë„ˆë¥¼ ë™ê²°í•˜ì—¬ ë³€ì¡° ë°©ì§€
container.freeze();

// ì´í›„ ë“±ë¡ ì‹œë„ëŠ” ì˜¤ë¥˜ ë°˜í™˜
auto result = container.register_type<IFoo, FooImpl>();
// result.is_err() == true, ì˜¤ë¥˜ ì½”ë“œ: REGISTRY_FROZEN

bool frozen = container.is_frozen();  // true
```

**ìˆœí™˜ ì˜ì¡´ì„± ê°ì§€:**

ì»¨í…Œì´ë„ˆëŠ” ìŠ¤ë ˆë“œ ë¡œì»¬ í•´ì„ ìŠ¤íƒì„ ì‚¬ìš©í•˜ì—¬ ëŸ°íƒ€ì„ì— ìˆœí™˜ ì˜ì¡´ì„±ì„ ê°ì§€í•©ë‹ˆë‹¤:

```cpp
// Aê°€ Bì— ì˜ì¡´í•˜ê³ , Bê°€ Aì— ì˜ì¡´í•˜ëŠ” ê²½ìš°:
auto result = container.resolve<A>();
// result.is_err() == true
// ì˜¤ë¥˜: "Circular dependency detected: A -> B -> A"
```

**ìŠ¤ë ˆë“œ ì•ˆì „ì„±:**
- ëª¨ë“  public ë©”ì„œë“œëŠ” `std::shared_mutex` (ì½ê¸°/ì“°ê¸° ì ê¸ˆ)ì„ ì‚¬ìš©í•˜ì—¬ ìŠ¤ë ˆë“œ ì•ˆì „í•©ë‹ˆë‹¤.
- ì‹±ê¸€í†¤ ì¸ìŠ¤í„´ìŠ¤í™”ëŠ” ì´ì¤‘ í™•ì¸ ì ê¸ˆì„ ì‚¬ìš©í•©ë‹ˆë‹¤.
- ìˆœí™˜ ì˜ì¡´ì„± ê°ì§€ëŠ” ì˜¤íƒì„ ë°©ì§€í•˜ê¸° ìœ„í•´ ìŠ¤ë ˆë“œ ë¡œì»¬ ì €ì¥ì†Œë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.

### ì‹œìŠ¤í…œ ë¶€íŠ¸ìŠ¤íŠ¸ë˜í¼

`SystemBootstrapper` (`kcenon::common::bootstrap`)ëŠ” ë¡œê±° ë“±ë¡ê³¼ ìƒëª…ì£¼ê¸° ê´€ë¦¬ë¥¼ í†µí•©í•˜ëŠ” ì• í”Œë¦¬ì¼€ì´ì…˜ ì´ˆê¸°í™”ë¥¼ ìœ„í•œ í”Œë£¨ì–¸íŠ¸ APIë¥¼ ì œê³µí•©ë‹ˆë‹¤.

**ì£¼ìš” ê¸°ëŠ¥:**
- í‘œí˜„ë ¥ ìˆëŠ” ì„¤ì •ì„ ìœ„í•œ í”Œë£¨ì–¸íŠ¸ ë©”ì„œë“œ ì²´ì´ë‹
- íŒ©í† ë¦¬ ê¸°ë°˜ ë¡œê±° ì§€ì—° ì´ˆê¸°í™”
- ì†Œë©¸ìì—ì„œ ìë™ ì¢…ë£Œí•˜ëŠ” RAII ì§€ì›
- ì¤‘ë³µ ì´ˆê¸°í™”/ì¢…ë£Œ ë°©ì§€
- ìŠ¤ë ˆë“œ ì•ˆì „ ë¡œê±° ì ‘ê·¼ì„ ìœ„í•œ `GlobalLoggerRegistry` í†µí•©

**API:**

```cpp
namespace kcenon::common::bootstrap {

class SystemBootstrapper {
public:
    SystemBootstrapper();
    ~SystemBootstrapper();  // ìë™ìœ¼ë¡œ shutdown() í˜¸ì¶œ

    // í”Œë£¨ì–¸íŠ¸ ì„¤ì •
    SystemBootstrapper& with_default_logger(LoggerFactory factory);
    SystemBootstrapper& with_logger(const std::string& name, LoggerFactory factory);
    SystemBootstrapper& on_initialize(std::function<void()> callback);
    SystemBootstrapper& on_shutdown(std::function<void()> callback);
    SystemBootstrapper& with_auto_freeze(
        bool freeze_logger_registry = true,
        bool freeze_service_container = true);

    // ìƒëª…ì£¼ê¸°
    VoidResult initialize();
    void shutdown();
    bool is_initialized() const noexcept;
    void reset();
};

}
```

**ì‚¬ìš© ì˜ˆì œ:**

```cpp
#include <kcenon/common/bootstrap/system_bootstrapper.h>

using namespace kcenon::common::bootstrap;

int main() {
    SystemBootstrapper bootstrapper;
    bootstrapper
        .with_default_logger([] { return create_console_logger(); })
        .with_logger("database", [] { return create_file_logger("db.log"); })
        .with_auto_freeze()  // ì´ˆê¸°í™” í›„ ë ˆì§€ìŠ¤íŠ¸ë¦¬ ë™ê²°
        .on_initialize([] { LOG_INFO("System started"); })
        .on_shutdown([] { LOG_INFO("System stopping"); });

    auto result = bootstrapper.initialize();
    if (result.is_err()) {
        std::cerr << "Init failed: " << result.error().message << "\n";
        return 1;
    }

    // ì• í”Œë¦¬ì¼€ì´ì…˜ ë¡œì§...

    return 0;
    // ~SystemBootstrapperê°€ ìë™ìœ¼ë¡œ shutdown() í˜¸ì¶œ
}
```

**ì´ˆê¸°í™” ìˆœì„œ:**
1. ê¸°ë³¸ ë¡œê±° ìƒì„± ë° ë“±ë¡ (ì„¤ì •ëœ ê²½ìš°)
2. ëª¨ë“  ëª…ëª…ëœ ë¡œê±° ìƒì„± ë° ë“±ë¡
3. ë“±ë¡ ìˆœì„œëŒ€ë¡œ ì´ˆê¸°í™” ì½œë°± ì‹¤í–‰
4. ë ˆì§€ìŠ¤íŠ¸ë¦¬ ë™ê²° (`with_auto_freeze()` í˜¸ì¶œ ì‹œ)

**ì¢…ë£Œ ìˆœì„œ:**
1. ì—­ìˆœìœ¼ë¡œ ì¢…ë£Œ ì½œë°± ì‹¤í–‰ (LIFO)
2. `GlobalLoggerRegistry`ì—ì„œ ëª¨ë“  ë¡œê±° ì œê±°

### í†µí•© ë¶€íŠ¸ìŠ¤íŠ¸ë˜í¼

`unified_bootstrapper` (`kcenon::common::di`)ëŠ” ì„œë¹„ìŠ¤ ì»¨í…Œì´ë„ˆë¥¼ í†µí•´ ì‹œìŠ¤í…œ ì „ì²´ ì´ˆê¸°í™”ì™€ ì¢…ë£Œë¥¼ ì¡°ìœ¨í•˜ëŠ” ì •ì  ìœ í‹¸ë¦¬í‹° í´ë˜ìŠ¤ì…ë‹ˆë‹¤. ì‹œê·¸ë„ ì²˜ë¦¬, ì¢…ë£Œ í›…, ì¡°ê±´ë¶€ í•˜ìœ„ ì‹œìŠ¤í…œ ë“±ë¡ì„ ì œê³µí•©ë‹ˆë‹¤.

**ì„¤ì • (`bootstrapper_options`):**

```cpp
namespace kcenon::common::di {

struct bootstrapper_options {
    bool enable_logging = true;           // ë¡œê¹… ì„œë¹„ìŠ¤ í™œì„±í™”
    bool enable_monitoring = true;        // ëª¨ë‹ˆí„°ë§ ì„œë¹„ìŠ¤ í™œì„±í™”
    bool enable_database = false;         // ë°ì´í„°ë² ì´ìŠ¤ ì„œë¹„ìŠ¤ í™œì„±í™”
    bool enable_network = false;          // ë„¤íŠ¸ì›Œí¬ ì„œë¹„ìŠ¤ í™œì„±í™”
    std::string config_path;              // ì„¤ì • íŒŒì¼ ê²½ë¡œ (ì„ íƒ ì‚¬í•­)
    std::chrono::milliseconds shutdown_timeout{30000};
    bool register_signal_handlers = true; // SIGTERM/SIGINT ì²˜ë¦¬
};

}
```

**API:**

```cpp
namespace kcenon::common::di {

class unified_bootstrapper {
public:
    // ìƒëª…ì£¼ê¸°
    static VoidResult initialize(const bootstrapper_options& opts = {});
    static VoidResult shutdown(
        std::chrono::milliseconds timeout = std::chrono::seconds(30));

    // ì„œë¹„ìŠ¤ ì ‘ê·¼
    static service_container& services();

    // ìƒíƒœ ì¡°íšŒ
    static bool is_initialized();
    static bool is_shutdown_requested();

    // ì¢…ë£Œ í›… (ì¢…ë£Œ ì‹œ LIFO ìˆœì„œë¡œ í˜¸ì¶œ)
    static VoidResult register_shutdown_hook(
        const std::string& name, shutdown_hook hook);
    static VoidResult unregister_shutdown_hook(const std::string& name);

    // ì‹œê·¸ë„ ì²˜ë¦¬
    static void request_shutdown(bool trigger_shutdown = false);

    // ì„¤ì •
    static bootstrapper_options get_options();
};

}
```

**ì‚¬ìš© ì˜ˆì œ:**

```cpp
#include <kcenon/common/di/unified_bootstrapper.h>

using namespace kcenon::common::di;

int main() {
    auto result = unified_bootstrapper::initialize({
        .enable_logging = true,
        .enable_monitoring = true,
        .config_path = "config.yaml",
        .register_signal_handlers = true
    });

    if (result.is_err()) {
        std::cerr << "Init failed: " << result.error().message << "\n";
        return 1;
    }

    // ì»¤ìŠ¤í…€ ì¢…ë£Œ í›… ë“±ë¡
    unified_bootstrapper::register_shutdown_hook("flush_cache",
        [](std::chrono::milliseconds remaining) {
            flush_all_caches();
        });

    // ì„œë¹„ìŠ¤ ì ‘ê·¼
    auto& services = unified_bootstrapper::services();
    auto logger = services.resolve<ILogger>();

    // ë©”ì¸ ë£¨í”„ - ì¢…ë£Œ ì‹œê·¸ë„ í™•ì¸
    while (!unified_bootstrapper::is_shutdown_requested()) {
        process_next_request();
    }

    unified_bootstrapper::shutdown();
    return 0;
}
```

**ì‹œê·¸ë„ ì²˜ë¦¬:**
- `SIGTERM`ê³¼ `SIGINT`ì— ëŒ€í•œ í•¸ë“¤ëŸ¬ë¥¼ ìë™ìœ¼ë¡œ ë“±ë¡í•©ë‹ˆë‹¤ (ì„¤ì • ê°€ëŠ¥).
- ì‹œê·¸ë„ ìˆ˜ì‹  ì‹œ ì¢…ë£Œ í”Œë˜ê·¸ë¥¼ ì„¤ì •í•©ë‹ˆë‹¤ (`is_shutdown_requested()`ê°€ `true` ë°˜í™˜).
- ì• í”Œë¦¬ì¼€ì´ì…˜ ì½”ë“œëŠ” í˜‘ë ¥ì  ì¢…ë£Œë¥¼ ìœ„í•´ `is_shutdown_requested()`ë¥¼ í´ë§í•´ì•¼ í•©ë‹ˆë‹¤.

**ì¢…ë£Œ í›…:**
- í›…ì€ ì¢…ë£Œ ì‹œ ì—­ìˆœìœ¼ë¡œ ì‹¤í–‰ë©ë‹ˆë‹¤ (LIFO).
- ê° í›…ì€ ë‚¨ì€ íƒ€ì„ì•„ì›ƒ ì‹œê°„ì„ ìˆ˜ì‹ í•˜ì—¬ ì‹œê°„ ì˜ˆì‚°ì„ ê³ ë ¤í•œ ì •ë¦¬ê°€ ê°€ëŠ¥í•©ë‹ˆë‹¤.
- í›…ì—ì„œ ë°œìƒí•œ ì˜ˆì™¸ëŠ” ì¡°ìš©íˆ í¬ì°©ë˜ì–´ ëª¨ë“  í›…ì´ ì‹¤í–‰ë˜ë„ë¡ í•©ë‹ˆë‹¤.

---

## í†µí•© ê¸°ëŠ¥

### thread_systemê³¼ì˜ í†µí•©

common_system ì¸í„°í˜ì´ìŠ¤ì™€ thread_systemì„ ì‚¬ìš©í•˜ê¸° ìœ„í•œ ì™„ì „í•œ í†µí•© ì˜ˆì œ:

```cpp
#include <kcenon/thread/core/thread_pool.h>
#include <kcenon/thread/adapters/common_executor_adapter.h>

// ìŠ¤ë ˆë“œ í’€ ìƒì„±
auto thread_pool = std::make_shared<kcenon::thread::thread_pool>(
    4  // ì›Œì»¤ ìŠ¤ë ˆë“œ
);

// common IExecutor ì¸í„°í˜ì´ìŠ¤ë¡œ ì ì‘
auto executor = kcenon::thread::adapters::make_common_executor(thread_pool);

// ì´ì œ ëª¨ë“  IExecutor ê¸°ë°˜ APIì™€ í•¨ê»˜ ì‚¬ìš©
void process_with_executor(std::shared_ptr<common::interfaces::IExecutor> exec) {
    auto future = exec->submit([]() {
        return compute_expensive_operation();
    });

    // ê³„ì‚°ì´ ì‹¤í–‰ë˜ëŠ” ë™ì•ˆ ë‹¤ë¥¸ ì‘ì—… ìˆ˜í–‰...

    auto result = future.get();
}

process_with_executor(executor);
```

### network_systemê³¼ì˜ í†µí•©

common executor ì¶”ìƒí™”ë¥¼ ì‚¬ìš©í•œ ë„¤íŠ¸ì›Œí¬ ì‘ì—…:

```cpp
#include <network_system/integration/executor_adapter.h>
#include <network_system/server.h>

void setup_network(std::shared_ptr<common::interfaces::IExecutor> executor) {
    // common executorë¥¼ ë„¤íŠ¸ì›Œí¬ ì‹œìŠ¤í…œì˜ ìŠ¤ë ˆë“œ í’€ ì¸í„°í˜ì´ìŠ¤ë¡œ ì ì‘
    auto network_pool = kcenon::network::integration::make_thread_pool_adapter(executor);

    // ì ì‘ëœ executorë¡œ ì„œë²„ ìƒì„±
    network_system::server server(network_pool);

    // ëª¨ë“  ë„¤íŠ¸ì›Œí¬ ì‘ì—…ì´ ì´ì œ common executor ì‚¬ìš©
    server.listen(8080);
}
```

### logger_systemê³¼ì˜ í†µí•©

ì˜¤ë¥˜ ì²˜ë¦¬ í†µí•©:

```cpp
#include <kcenon/logger/logger.h>
#include <kcenon/common/patterns/result.h>

common::Result<void> initialize_logging(const std::string& log_path) {
    try {
        auto logger = kcenon::logger::create_logger(log_path);

        if (!logger) {
            return common::make_error<void>(
                common::error_codes::INITIALIZATION_FAILED,
                "ë¡œê±° ìƒì„± ì‹¤íŒ¨",
                "initialize_logging"
            );
        }

        return common::ok();

    } catch (const std::exception& e) {
        return common::make_error<void>(
            common::error_codes::EXCEPTION,
            e.what(),
            "initialize_logging"
        );
    }
}

// ì‚¬ìš©
auto result = initialize_logging("/var/log/app.log");
if (!result) {
    std::cerr << "ë¡œê¹… ì´ˆê¸°í™” ì‹¤íŒ¨: "
              << result.error().message << "\n";
    return 1;
}
```

### ì—ì½”ì‹œìŠ¤í…œ í†µí•© í”Œë˜ê·¸

ì—ì½”ì‹œìŠ¤í…œ ëª¨ë“ˆê³¼ì˜ ìœ ì—°í•œ í†µí•©ì„ ìœ„í•´:

**ì‚¬ìš© ê°€ëŠ¥í•œ í”Œë˜ê·¸:**

- `KCENON_WITH_COMMON_SYSTEM`: common_system íƒ€ì… ì‚¬ìš© ê°€ëŠ¥ (í—¤ë” í¬í•¨ ì‹œ ìë™ ì„¤ì •)
- `KCENON_WITH_THREAD_SYSTEM`: thread_system í†µí•© í™œì„±í™”
- `KCENON_WITH_CONTAINER_SYSTEM`: container_system í†µí•© í™œì„±í™”
- `KCENON_WITH_LOGGER_SYSTEM`: logger_system í†µí•© í™œì„±í™”
- `KCENON_WITH_MONITORING_SYSTEM`: monitoring_system í†µí•© í™œì„±í™”
- `KCENON_WITH_NETWORK_SYSTEM`: network_system í†µí•© í™œì„±í™”
- `KCENON_WITH_DATABASE_SYSTEM`: database_system í†µí•© í™œì„±í™”

**CMake ì‚¬ìš©:**

```cmake
include(cmake/features.cmake)

# ê¸°ëŠ¥ í”Œë˜ê·¸ ì„¤ì •
kcenon_configure_features(my_target
    THREAD_SYSTEM ON
    LOGGER_SYSTEM ON
    DATABASE_SYSTEM ON
)

# ë˜ëŠ” ì „í†µì ì¸ ì»´íŒŒì¼ ì •ì˜ ì‚¬ìš©
target_compile_definitions(my_target PUBLIC
    KCENON_WITH_THREAD_SYSTEM=1
    KCENON_WITH_LOGGER_SYSTEM=1
)

# íƒ€ê²Ÿì— ë§í¬
target_link_libraries(my_app
    PRIVATE
        kcenon::common
        kcenon::thread
        kcenon::logger
        kcenon::database
)
```

---

## í”„ë¡œë•ì…˜ í’ˆì§ˆ ê¸°ëŠ¥

### ë¹Œë“œ ë° í…ŒìŠ¤íŒ… ì¸í”„ë¼

**ë©€í‹° í”Œë«í¼ ì§€ì†ì  í†µí•©:**

common_systemì€ ì—¬ëŸ¬ í”Œë«í¼ê³¼ ì»´íŒŒì¼ëŸ¬ì—ì„œ ì§€ì†ì ìœ¼ë¡œ í…ŒìŠ¤íŠ¸ë©ë‹ˆë‹¤:

- **Ubuntu Linux**
  - GCC 7, 9, 11, 13
  - Clang 5, 10, 14, 16
  - ì™„ì „í•œ ìƒˆë‹ˆíƒ€ì´ì € ì»¤ë²„ë¦¬ì§€

- **macOS**
  - Apple Clang (Xcode 12, 13, 14, 15)
  - arm64 ë° x86_64 ì•„í‚¤í…ì²˜
  - ë„¤ì´í‹°ë¸Œ M1/M2 í…ŒìŠ¤íŒ…

- **Windows**
  - MSVC 2017, 2019, 2022
  - x86 ë° x64 ë¹Œë“œ ëª¨ë‘
  - Debug ë° Release êµ¬ì„±

**ìë™í™”ëœ ìƒˆë‹ˆíƒ€ì´ì € ë¹Œë“œ:**

ëª¨ë“  ì»¤ë°‹ì€ ë‹¤ìŒìœ¼ë¡œ í…ŒìŠ¤íŠ¸ë©ë‹ˆë‹¤:
- **ThreadSanitizer (TSan)**: ë°ì´í„° ë ˆì´ìŠ¤ ë° ìŠ¤ë ˆë”© ë¬¸ì œ ê°ì§€
- **AddressSanitizer (ASan)**: ë©”ëª¨ë¦¬ ì˜¤ë¥˜ ë° ëˆ„ìˆ˜ ê°ì§€
- **UndefinedBehaviorSanitizer (UBSan)**: ì •ì˜ë˜ì§€ ì•Šì€ ë™ì‘ í¬ì°©

**í’ˆì§ˆ ë©”íŠ¸ë¦­:**

í˜„ì¬ í”„ë¡œë•ì…˜ í’ˆì§ˆ ë©”íŠ¸ë¦­:
- í…ŒìŠ¤íŠ¸ ì»¤ë²„ë¦¬ì§€: 80%+ (ëª©í‘œ: 85%)
- ìƒˆë‹ˆíƒ€ì´ì € í…ŒìŠ¤íŠ¸: 18/18 ì œë¡œ ê²½ê³ ë¡œ í†µê³¼
- ì •ì  ë¶„ì„: ë² ì´ìŠ¤ë¼ì¸ ìˆ˜ë¦½, ìƒˆë¡œìš´ ê²½ê³  ì œë¡œ
- ë¬¸ì„œ ì»¤ë²„ë¦¬ì§€: ê³µê°œ APIì˜ 100%

### ìŠ¤ë ˆë“œ ì•ˆì „ì„± ë° ë™ì‹œì„±

**ì„¤ê³„ìƒ ìŠ¤ë ˆë“œ ì•ˆì „:**

ëª¨ë“  common_system ì¸í„°í˜ì´ìŠ¤ëŠ” ì•ˆì „í•œ ë™ì‹œ ì ‘ê·¼ì„ ìœ„í•´ ì„¤ê³„ë˜ì—ˆìŠµë‹ˆë‹¤:

- **Result<T>**: ìƒì„± í›„ ë¶ˆë³€, ìŠ¤ë ˆë“œ ê°„ ê³µìœ  ì•ˆì „
- **IExecutor**: ìŠ¤ë ˆë“œ ì•ˆì „ submit() ë° execute() ì—°ì‚°
- **ì´ë²¤íŠ¸ ë²„ìŠ¤**: ë½í”„ë¦¬ ê²Œì‹œ/êµ¬ë… ì—°ì‚°
- **ì˜¤ë¥˜ ë ˆì§€ìŠ¤íŠ¸ë¦¬**: ì»´íŒŒì¼ íƒ€ì„ ì´ˆê¸°í™”, ëŸ°íƒ€ì„ ì½ê¸° ì „ìš©

**ë™ì‹œì„± ë³´ì¥:**

```cpp
// ì•ˆì „í•œ ë™ì‹œ Result<T> ì‚¬ìš©
void worker_thread(std::shared_ptr<Result<Data>> result) {
    // ì—¬ëŸ¬ ìŠ¤ë ˆë“œê°€ ë™ì¼í•œ Resultë¥¼ ì•ˆì „í•˜ê²Œ ì½ì„ ìˆ˜ ìˆìŒ
    if (result->is_ok()) {
        process(result->value());
    }
}

// ì•ˆì „í•œ ë™ì‹œ IExecutor ì‚¬ìš©
void process_batch(std::shared_ptr<IExecutor> executor,
                  const std::vector<Task>& tasks) {
    // ì—¬ëŸ¬ ìŠ¤ë ˆë“œê°€ ë™ì¼í•œ ì‹¤í–‰ê¸°ì— ì œì¶œ ê°€ëŠ¥
    for (const auto& task : tasks) {
        executor->submit([task]() {
            task.execute();
        });
    }
}
```

**ê²€ì¦:**

- ëª¨ë“  ì—ì½”ì‹œìŠ¤í…œ ì»´í¬ë„ŒíŠ¸ì—ì„œ ThreadSanitizer ì¤€ìˆ˜ í™•ì¸
- í”„ë¡œë•ì…˜ ì‚¬ìš©ì—ì„œ ì œë¡œ ë°ì´í„° ë ˆì´ìŠ¤ ê²½ê³ 
- í¬ê´„ì ì¸ ë™ì‹œì„± ê³„ì•½ ë¬¸ì„œ
- ëª¨ë“  ê³µìœ  ìƒíƒœì— ëŒ€í•œ ì ì ˆí•œ ë™ê¸°í™”

### ë¦¬ì†ŒìŠ¤ ê´€ë¦¬ (RAII - Aë“±ê¸‰)

**ì™„ë²½í•œ RAII ì¤€ìˆ˜:**

common_systemì˜ ëª¨ë“  ë¦¬ì†ŒìŠ¤ëŠ” RAII ì›ì¹™ì„ ë”°ë¦…ë‹ˆë‹¤:

- ìŠ¤ë§ˆíŠ¸ í¬ì¸í„°(`std::shared_ptr`, `std::unique_ptr`)ë¥¼ í†µí•´ ëª¨ë“  ë¦¬ì†ŒìŠ¤ ê´€ë¦¬
- ì½”ë“œë² ì´ìŠ¤ ì–´ë””ì—ì„œë„ ìˆ˜ë™ ë©”ëª¨ë¦¬ ê´€ë¦¬ ì—†ìŒ
- ìŠ¤ì½”í”„ ì¢…ë£Œ ì‹œ ìë™ ì •ë¦¬
- ì„¤ê³„ìƒ ì˜ˆì™¸ ì•ˆì „

**ê²€ì¦ ê²°ê³¼:**

- AddressSanitizer: ì œë¡œ ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ë¡œ 18/18 í…ŒìŠ¤íŠ¸ í†µê³¼
- ëª¨ë“  ì˜¤ë¥˜ ê²½ë¡œì—ì„œ ë¦¬ì†ŒìŠ¤ ì •ë¦¬ í™•ì¸
- í”„ë¡œë•ì…˜ ì‚¬ìš©ì—ì„œ ë¦¬ì†ŒìŠ¤ ëˆ„ìˆ˜ ê°ì§€ë˜ì§€ ì•ŠìŒ
- ëª¨ë“  ì—°ì‚°ì—ì„œ ì˜ˆì™¸ ì•ˆì „ì„± ê²€ì¦

---

## ì˜¤ë¥˜ ì²˜ë¦¬ ê¸°ë°˜

common_systemì€ ì—ì½”ì‹œìŠ¤í…œì˜ ëª¨ë“  ì‹œìŠ¤í…œì— ê±¸ì³ ì˜¤ë¥˜ ì²˜ë¦¬ë¥¼ ìœ„í•œ **ê¸°ë°˜ ì œê³µì** ì—­í• ì„ í•©ë‹ˆë‹¤.

### ì¤‘ì•™ ì§‘ì¤‘ì‹ ì˜¤ë¥˜ ì½”ë“œ ë ˆì§€ìŠ¤íŠ¸ë¦¬

ì‹œìŠ¤í…œë³„ ë²”ìœ„ë¥¼ ì œê³µí•˜ëŠ” ì™„ì „í•œ ì˜¤ë¥˜ ì½”ë“œ ë ˆì§€ìŠ¤íŠ¸ë¦¬:

| ì‹œìŠ¤í…œ | ì˜¤ë¥˜ ì½”ë“œ ë²”ìœ„ | ëª©ì  |
|--------|-----------------|---------|
| common_system | -1 ~ -99 | ê¸°ë°˜ ì˜¤ë¥˜ (ê²€ì¦, ì´ˆê¸°í™”) |
| thread_system | -100 ~ -199 | ìŠ¤ë ˆë”© ì˜¤ë¥˜ (êµì°© ìƒíƒœ, í’€ ê³ ê°ˆ) |
| logger_system | -200 ~ -299 | ë¡œê¹… ì˜¤ë¥˜ (íŒŒì¼ I/O, í¬ë§·íŒ…) |
| monitoring_system | -300 ~ -399 | ëª¨ë‹ˆí„°ë§ ì˜¤ë¥˜ (ë©”íŠ¸ë¦­ ìˆ˜ì§‘, ê²Œì‹œ) |
| container_system | -400 ~ -499 | ì»¨í…Œì´ë„ˆ ì˜¤ë¥˜ (ì§ë ¬í™”, ê²€ì¦) |
| database_system | -500 ~ -599 | ë°ì´í„°ë² ì´ìŠ¤ ì˜¤ë¥˜ (ì—°ê²°, ì¿¼ë¦¬, íŠ¸ëœì­ì…˜) |
| network_system | -600 ~ -699 | ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜ (ì—°ê²°, íƒ€ì„ì•„ì›ƒ, í”„ë¡œí† ì½œ) |

**ì»´íŒŒì¼ íƒ€ì„ ê²€ì¦:**

ì˜¤ë¥˜ ì½”ë“œ ë²”ìœ„ëŠ” ì¶©ëŒì„ ë°©ì§€í•˜ê¸° ìœ„í•´ ì»´íŒŒì¼ íƒ€ì„ì— ê°•ì œë©ë‹ˆë‹¤:

```cpp
namespace common::error_codes {
    // ì»´íŒŒì¼ íƒ€ì„ ë²”ìœ„ ê²€ì‚¬
    constexpr int COMMON_MIN = -1;
    constexpr int COMMON_MAX = -99;

    constexpr bool is_valid_common_code(int code) {
        return code >= COMMON_MIN && code <= COMMON_MAX;
    }

    static_assert(is_valid_common_code(NOT_FOUND));
    static_assert(is_valid_common_code(INVALID_ARGUMENT));
}
```

### ì—ì½”ì‹œìŠ¤í…œ ì±„íƒ

ëª¨ë“  ì˜ì¡´ ì‹œìŠ¤í…œì´ Result<T> íŒ¨í„´ê³¼ ì˜¤ë¥˜ ì½”ë“œ ë ˆì§€ìŠ¤íŠ¸ë¦¬ë¥¼ ì„±ê³µì ìœ¼ë¡œ ì±„íƒí–ˆìŠµë‹ˆë‹¤:

**ì±„íƒ ìƒíƒœ:**

- âœ… thread_system: ëª¨ë“  ì—°ì‚°ì— ëŒ€í•œ ì™„ì „í•œ Result<T> í†µí•©
- âœ… logger_system: Result<T>ë¥¼ í†µí•œ ì˜¤ë¥˜ ì²˜ë¦¬, ì˜ˆì™¸ ì—†ìŒ
- âœ… monitoring_system: ë©”íŠ¸ë¦­ ì—°ì‚°ì— Result<T>
- âœ… container_system: ì§ë ¬í™” ì—°ì‚°ì´ Result<T> ë°˜í™˜
- âœ… database_system: ì¿¼ë¦¬ ê²°ê³¼ ë° íŠ¸ëœì­ì…˜ì´ Result<T> ì‚¬ìš©
- âœ… network_system: ì—°ê²° ë° I/O ì—°ì‚°ì´ Result<T> ë°˜í™˜

**ì‹¤í˜„ëœ ì´ì :**

- ëª¨ë“  ì‹œìŠ¤í…œì—ì„œ ì¼ê´€ëœ ì˜¤ë¥˜ ì²˜ë¦¬
- í”„ë¡œë•ì…˜ì—ì„œ ì˜ˆê¸°ì¹˜ ì•Šì€ ì˜ˆì™¸ ì—†ìŒ
- ëª…í™•í•œ ì˜¤ë¥˜ ì „íŒŒ ê²½ë¡œ
- ê°œì„ ëœ ì˜¤ë¥˜ ë³µêµ¬ ë° ë³µì›ë ¥
- ë” ë‚˜ì€ ì˜¤ë¥˜ ë¡œê¹… ë° ì§„ë‹¨

---

## ê³ ê¸‰ ê¸°ëŠ¥

### Source Location ì§€ì› (C++20)

C++20ìœ¼ë¡œ ì»´íŒŒì¼ ì‹œ common_systemì€ í–¥ìƒëœ ì˜¤ë¥˜ ì§„ë‹¨ì„ ì œê³µí•©ë‹ˆë‹¤:

```cpp
#include <kcenon/common/utils/source_location.h>

// ìë™ source_location ìº¡ì²˜ë¡œ ë¡œê¹…
logger->log(log_level::info, "ì‘ì—… ì™„ë£Œ");
// íŒŒì¼, ë¼ì¸, í•¨ìˆ˜ ì •ë³´ê°€ ìë™ìœ¼ë¡œ ìº¡ì²˜ë¨

// log_entry íŒ©í† ë¦¬ ë©”ì„œë“œ ì‚¬ìš©
auto entry = log_entry::create(log_level::error, "ì—°ê²° ì‹¤íŒ¨");
// entry.file, entry.line, entry.functionì´ ìë™ìœ¼ë¡œ ì±„ì›Œì§

// Result<T>ì—ì„œ í–¥ìƒëœ ì˜¤ë¥˜ ë©”ì‹œì§€
auto result = some_operation();
if (result.is_err()) {
    result.unwrap();  // ì—ëŸ¬ ì‹œ íŒŒì¼/ë¼ì¸/í•¨ìˆ˜ ì •ë³´ í¬í•¨ ì˜ˆì™¸ ë°œìƒ
}
```

**C++17 í´ë°±**:
- C++17ì—ì„œëŠ” `__FILE__`, `__LINE__`, `__FUNCTION__` ë§¤í¬ë¡œë¡œ í´ë°±
- ë™ì¼í•œ API ìœ ì§€, ëŸ°íƒ€ì„ ë¹„ìš© ì—†ìŒ

### ABI ë²„ì „ ê²€ì‚¬

ì»´íŒŒì¼ íƒ€ì„ ABI í˜¸í™˜ì„± ê²€ì¦:

```cpp
namespace kcenon::common::abi {
    constexpr int MAJOR = 1;
    constexpr int MINOR = 0;
    constexpr int PATCH = 0;

    constexpr int VERSION = (MAJOR << 16) | (MINOR << 8) | PATCH;
}

// í´ë¼ì´ì–¸íŠ¸ ì½”ë“œì—ì„œ ABI í˜¸í™˜ì„± ê²€ì¦ ê°€ëŠ¥
static_assert(kcenon::common::abi::MAJOR == 1, "í˜¸í™˜ë˜ì§€ ì•ŠëŠ” ABI ë²„ì „");
```

### ì»¤ìŠ¤í…€ ì—ëŸ¬ íƒ€ì…

ì—ëŸ¬ ì‹œìŠ¤í…œì„ ì»¤ìŠ¤í…€ ì—ëŸ¬ íƒ€ì…ìœ¼ë¡œ í™•ì¥:

```cpp
namespace my_system::errors {
    // common ë²”ìœ„ ì™¸ë¶€ì˜ ì»¤ìŠ¤í…€ ì—ëŸ¬ ì½”ë“œ
    constexpr int MY_CUSTOM_ERROR = -1001;

    inline std::string get_error_message(int code) {
        if (code == MY_CUSTOM_ERROR) {
            return "ì»¤ìŠ¤í…€ ì—ëŸ¬ ë°œìƒ";
        }
        return kcenon::common::get_error_message(code);
    }
}

// ê°•íƒ€ì… enum ì—ëŸ¬ ì½”ë“œë„ ì§€ì›
enum class DatabaseError {
    connection_failed = -501,
    query_failed = -502,
    transaction_failed = -503
};

// error_info ìƒì„± ì‹œ enum ì§ì ‘ ì‚¬ìš© ê°€ëŠ¥
auto err = error_info{DatabaseError::connection_failed, "ì—°ê²° ì‹¤íŒ¨"};
```

### vcpkg ë° Conan ì§€ì›

íŒ¨í‚¤ì§€ ê´€ë¦¬ìë¥¼ í†µí•œ ê°„í¸í•œ í†µí•©:

**Conan ì‚¬ìš©**:
```bash
# ì†ŒìŠ¤ì—ì„œ íŒ¨í‚¤ì§€ ìƒì„±
conan create . --build=missing

# conanfile.txtì— ì¶”ê°€
[requires]
common_system/1.0.0

# ì„¤ì¹˜
conan install . --build=missing
```

**CMake FetchContent ì‚¬ìš© (ê¶Œì¥)**:
```cmake
include(FetchContent)
FetchContent_Declare(
    common_system
    GIT_REPOSITORY https://github.com/kcenon/common_system.git
    GIT_TAG main
)
FetchContent_MakeAvailable(common_system)

target_link_libraries(your_target PRIVATE kcenon::common)
```

### í”„ë¡œë•ì…˜ ì˜ˆì œ

#### ì™„ì „í•œ ì• í”Œë¦¬ì¼€ì´ì…˜ ì´ˆê¸°í™”

```cpp
#include <kcenon/common/bootstrap/system_bootstrapper.h>
#include <kcenon/common/logging/log_macros.h>

using namespace kcenon::common::bootstrap;
using namespace kcenon::common::interfaces;

int main() {
    SystemBootstrapper bootstrapper;
    bootstrapper
        .with_default_logger([]() {
            return std::make_shared<ConsoleLogger>();
        })
        .with_logger("network", []() {
            return std::make_shared<FileLogger>("network.log");
        })
        .on_initialize([]() {
            LOG_INFO("ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì™„ë£Œ");
        })
        .on_shutdown([]() {
            LOG_INFO("ì‹œìŠ¤í…œ ì¢…ë£Œ ì¤‘");
        });

    if (auto result = bootstrapper.initialize(); result.is_err()) {
        std::cerr << "ì´ˆê¸°í™” ì‹¤íŒ¨: " << result.error().message;
        return 1;
    }

    // ì• í”Œë¦¬ì¼€ì´ì…˜ ë¡œì§...
    LOG_INFO("ì„œë²„ ì‹œì‘");
    LOG_INFO_TO("network", "í¬íŠ¸ 8080ì—ì„œ ëŒ€ê¸° ì¤‘");

    // RAIIë¡œ ìë™ ì •ë¦¬
    return 0;
}
```

#### Job ê¸°ë°˜ Executor ì‚¬ìš©

```cpp
#include <kcenon/common/interfaces/executor_interface.h>

using namespace kcenon::common;
using namespace kcenon::common::interfaces;

class DataProcessingJob : public IJob {
    std::vector<int> data_;
public:
    DataProcessingJob(std::vector<int> data) : data_(std::move(data)) {}

    VoidResult execute() override {
        // ë°ì´í„° ì²˜ë¦¬ ë¡œì§
        for (auto& item : data_) {
            item *= 2;
        }
        return ok();
    }

    std::string get_name() const override { return "data_processing"; }
    int get_priority() const override { return 10; }
};

void process_data(std::shared_ptr<IExecutor> executor) {
    auto job = std::make_unique<DataProcessingJob>(std::vector{1, 2, 3, 4, 5});

    auto result = executor->execute(std::move(job));
    if (result.is_ok()) {
        result.value().wait();  // ì™„ë£Œ ëŒ€ê¸°
        LOG_INFO("ë°ì´í„° ì²˜ë¦¬ ì™„ë£Œ");
    } else {
        LOG_ERROR("ì‹¤í–‰ ì‹¤íŒ¨: " + result.error().message);
    }
}
```

#### Result<T> ëª¨ë‚˜ë”• ì²´ì´ë‹

```cpp
#include <kcenon/common/patterns/result.h>

using namespace kcenon::common;

Result<Config> load_and_validate_config(const std::string& path) {
    return load_config(path)
        .and_then([](const Config& cfg) -> Result<Config> {
            if (cfg.port <= 0 || cfg.port > 65535) {
                return make_error<Config>(
                    error_codes::INVALID_ARGUMENT,
                    "ì˜ëª»ëœ í¬íŠ¸ ë²ˆí˜¸",
                    "config_validator"
                );
            }
            return Result<Config>::ok(cfg);
        })
        .map([](const Config& cfg) {
            auto validated = cfg;
            validated.validated = true;
            return validated;
        })
        .or_else([](const error_info& err) -> Result<Config> {
            LOG_WARNING("ì„¤ì • ë¡œë“œ ì‹¤íŒ¨, ê¸°ë³¸ê°’ ì‚¬ìš©: " + err.message);
            return Result<Config>::ok(Config::default_config());
        });
}
```

---

**ìµœì¢… ì—…ë°ì´íŠ¸**: 2026-02-08
**ë²„ì „**: 0.2.0

---

Made with â¤ï¸ by ğŸ€â˜€ğŸŒ•ğŸŒ¥ ğŸŒŠ
